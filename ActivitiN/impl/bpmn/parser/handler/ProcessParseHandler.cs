using System;
using System.Collections.Generic;

/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace org.activiti.engine.impl.bpmn.parser.handler
{


	using BaseElement = org.activiti.bpmn.model.BaseElement;
	using EventListener = org.activiti.bpmn.model.EventListener;
	using ImplementationType = org.activiti.bpmn.model.ImplementationType;
	using Process = org.activiti.bpmn.model.Process;
	using ActivitiEventType = org.activiti.engine.@delegate.@event.ActivitiEventType;
	using IOSpecification = org.activiti.engine.impl.bpmn.data.IOSpecification;
	using ExpressionManager = org.activiti.engine.impl.el.ExpressionManager;
	using ProcessDefinitionEntity = org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntity;
	using TaskDefinition = org.activiti.engine.impl.task.TaskDefinition;
	using Logger = org.slf4j.Logger;
	using LoggerFactory = org.slf4j.LoggerFactory;

	/// <summary>
	/// @author Joram Barrez
	/// </summary>
	public class ProcessParseHandler : AbstractBpmnParseHandler<Process>
	{

	  private static readonly Logger LOGGER = LoggerFactory.getLogger(typeof(ProcessParseHandler));

	  public const string PROPERTYNAME_DOCUMENTATION = "documentation";

	  public virtual Type HandledType
	  {
		  get
		  {
			return typeof(Process);
		  }
	  }

	  protected internal virtual void executeParse(BpmnParse bpmnParse, Process process)
	  {
		if (process.Executable == false)
		{
		  LOGGER.info("Ignoring non-executable process with id='" + process.Id + "'. Set the attribute isExecutable=\"true\" to deploy this process.");
		}
		else
		{
		  bpmnParse.ProcessDefinitions.Add(transformProcess(bpmnParse, process));
		}
	  }

	  protected internal virtual ProcessDefinitionEntity transformProcess(BpmnParse bpmnParse, Process process)
	  {
		ProcessDefinitionEntity currentProcessDefinition = new ProcessDefinitionEntity();
		bpmnParse.CurrentProcessDefinition = currentProcessDefinition;

		/*
		 * Mapping object model - bpmn xml: processDefinition.id -> generated by
		 * activiti engine processDefinition.key -> bpmn id (required)
		 * processDefinition.name -> bpmn name (optional)
		 */
		currentProcessDefinition.Key = process.Id;
		currentProcessDefinition.Name = process.Name;
		currentProcessDefinition.Category = bpmnParse.BpmnModel.TargetNamespace;
		currentProcessDefinition.Description = process.Documentation;
		currentProcessDefinition.setProperty(PROPERTYNAME_DOCUMENTATION, process.Documentation); // Kept for backwards compatibility. See ACT-1020
		currentProcessDefinition.TaskDefinitions = new Dictionary<string, TaskDefinition>();
		currentProcessDefinition.DeploymentId = bpmnParse.Deployment.Id;
		createExecutionListenersOnScope(bpmnParse, process.ExecutionListeners, currentProcessDefinition);
		createEventListeners(bpmnParse, process.EventListeners, currentProcessDefinition);

		ExpressionManager expressionManager = bpmnParse.ExpressionManager;

		foreach (string candidateUser in process.CandidateStarterUsers)
		{
		  currentProcessDefinition.addCandidateStarterUserIdExpression(expressionManager.createExpression(candidateUser));
		}

		foreach (string candidateGroup in process.CandidateStarterGroups)
		{
		  currentProcessDefinition.addCandidateStarterGroupIdExpression(expressionManager.createExpression(candidateGroup));
		}

		if (LOGGER.DebugEnabled)
		{
		  LOGGER.debug("Parsing process {}", currentProcessDefinition.Key);
		}

		bpmnParse.CurrentScope = currentProcessDefinition;

		bpmnParse.processFlowElements(process.FlowElements);
		processArtifacts(bpmnParse, process.Artifacts, currentProcessDefinition);

		// parse out any data objects from the template in order to set up the necessary process variables
		IDictionary<string, object> variables = processDataObjects(bpmnParse, process.DataObjects, currentProcessDefinition);
		if (null != currentProcessDefinition.Variables)
		{
//JAVA TO C# CONVERTER TODO TASK: There is no .NET Dictionary equivalent to the Java 'putAll' method:
		  currentProcessDefinition.Variables.putAll(variables);
		}
		else
		{
		  currentProcessDefinition.Variables = variables;
		}

		bpmnParse.removeCurrentScope();

		if (process.IoSpecification != null)
		{
		  IOSpecification ioSpecification = createIOSpecification(bpmnParse, process.IoSpecification);
		  currentProcessDefinition.IoSpecification = ioSpecification;
		}
		return currentProcessDefinition;
	  }

		protected internal virtual void createEventListeners(BpmnParse bpmnParse, IList<EventListener> eventListeners, ProcessDefinitionEntity currentProcessDefinition)
		{

			if (eventListeners != null && eventListeners.Count > 0)
			{
				foreach (EventListener eventListener in eventListeners)
				{
					// Extract specific event-types (if any)
					ActivitiEventType[] types = ActivitiEventType.getTypesFromString(eventListener.Events);

					if (ImplementationType.IMPLEMENTATION_TYPE_CLASS.Equals(eventListener.ImplementationType))
					{
						currentProcessDefinition.EventSupport.addEventListener(bpmnParse.ListenerFactory.createClassDelegateEventListener(eventListener),types);
					}
					else if (ImplementationType.IMPLEMENTATION_TYPE_DELEGATEEXPRESSION.Equals(eventListener.ImplementationType))
					{
						currentProcessDefinition.EventSupport.addEventListener(bpmnParse.ListenerFactory.createDelegateExpressionEventListener(eventListener), types);
					}
					else if (ImplementationType.IMPLEMENTATION_TYPE_THROW_SIGNAL_EVENT.Equals(eventListener.ImplementationType) || ImplementationType.IMPLEMENTATION_TYPE_THROW_GLOBAL_SIGNAL_EVENT.Equals(eventListener.ImplementationType) || ImplementationType.IMPLEMENTATION_TYPE_THROW_MESSAGE_EVENT.Equals(eventListener.ImplementationType) || ImplementationType.IMPLEMENTATION_TYPE_THROW_ERROR_EVENT.Equals(eventListener.ImplementationType))
					{
						currentProcessDefinition.EventSupport.addEventListener(bpmnParse.ListenerFactory.createEventThrowingEventListener(eventListener), types);
					}
					else
					{
						LOGGER.warn("Unsupported implementation type for EventLIstener: " + eventListener.ImplementationType + " for element " + bpmnParse.CurrentFlowElement.Id);
					}
				}
			}

		}

	}

}